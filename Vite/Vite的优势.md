# Vite 的优势

### vite 是什么

- vite 是一个由原生 ESM 驱动的非打包开发服务器。

### 打包的基本概念

- 打包的基本概念就是使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

### 目前的打包工具有哪些？

- 目前最常用的打包工具有类似于 webpack、Rollup、Parcel 等工具。

### 为什么会有 Vite 的产生

- 当我们构建大型项目的时候，有可能会包含上千个模块，那么会有可能会有性能问题，使用 JavaScript 开发工具通常需要很长时间才能启动服务器，即使使用 HMR，文件修改后的效果也需要几秒才能显示出来，降低了开发的效率。
- Vite 就是利用生态系统中的新进展解决上述问题。

### webpack 与 vite 的区别

- webpack 会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。vite 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
- 由于现代浏览器本身就支持 ESM，会自动向依赖的 Module 发出请求，vite 充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像 webpack 那样进行打包合并。
- vite 在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快，当浏览器请求某个模块的时候，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大地缩短了编译时间。
- 在 HMR 方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像 webpack 那样需要把该模块的相关依赖模块全部编译一次，效率更高。
- 当需要打包到生产环境的时候，vite 使用传统的 rollup(也可以自己手动配置 webpack)进行打包，所以 vite 的主要优势在开发阶段，另外，vite 利用的是 ESM，所以不可以使用 CommonJS。

### 服务器启动

- 当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。
- Vite 会将应用中的模块区分为 **依赖** 和 **源码** 两类，优化了开发服务器启动时间。
  - **依赖**：在开发过程中不会变动的纯 JavaScript。
  - **源码**：通常包含一些并非直接是 JavaScript 的文件，需要转化的，而且有可能会被编辑。并且并不是所有的源码都需要被同时加载，例如基于路由拆分的代码模块。
  - Vite 只需要在浏览器请求源码时进行转换并按需提供源码。

### 服务器更新

- 基于打包器启动时，重建整个包的效率很低，因为这样更新速度会随着应用体积增长而直线下降。即使打包器执行动态模块热重载(HMR)：允许一个模块“热替换”自己，而对页面其余部分没有影响，大大改进了开发体验，而在实践中我们发现，即使是 HMR 更新速度也会随着应用规模的增长而显著下降。
- 在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效(大多数时候只需要模块本身)，使 HMR 更新始终快速，无论应用的大小。Vite 同时利用 HTTP 头来加速整个页面的重新加载，源码模块的请求会根据 304 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

### 为什么生产环境仍需要打包

- 尽管原生 ESM 现在得到了广泛的支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下，为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割。
