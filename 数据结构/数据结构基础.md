# 数据结构基础

## 数据结构
- 数据结构包括了三个要素：数据的逻辑结构、数据的存储结构、数据的运算。

### 数据的逻辑结构
- 数据的逻辑结构有：
   - 集合结构：元素间的次序是任意的。元素之间除了“属于同一集合”的联系外没有其他的关系。
   - 线性结构：数据元素的有序序列。除了第一个和最后一个元素外，其余元素都有一个前趋和一个后继，1对1。
   - 树形结构：除了根元素外，每个节点有且仅有一个前趋，后继数目不限，1对多。
   - 图型结构：每个元素的前趋和后继数目都不限，多对多。
- 数据的逻辑结构还分为线性结构与非线性结构：
   - 线性结构包括线性表、栈和队列、字符串。
   - 非线性结构包括：树、图。
   
### 数据的存储结构
- 数据的存储结构分为两个部分：数据元素的存储和数据元素之间的关系存储。
   - 物理结构由三个部分组成：
      1. 存储结点，每个存储结点存放一个数据元素；
      2. 数据元素之间的关系的存储，也就是逻辑结构的机内表示；
      3. 附加信息，便于运算实现而设置的一些“哑结点”，如链表中的头结点。 
   -  关系存储：
      1. 顺序存储：用存储的位置表示元素之间的关系，主要用数组实现。
      2. 链接存储：用指针显式地指出元素之间的关系，如单链表就是表示线性关系的
      3. 哈希存储方式：是专用于集合结构的数据存放方式。在哈希存储中，各个结点均匀地分布在一块连续的存储区域中，用一个哈希函数将数据元素和存储位置关联起来。
      4. 索引存储方式：所有的存储结点按照生成的次序连续存放，另外设置一个索引区域表示结点之间的关系。 

### 数据的运算
- 数据的运算方法：检索、排序、插入、删除、修改等。

## 算法分析
- 算法的优劣的重要依据是看执行该算法的程序需要占用多少机器资源，即程序所用算法运行时所要花费的时间代价和程序中使用的数据结构占有的空间代价。
### 算法的时间复杂度
- 算法的时间复杂度是一种抽象的度量，即运算量与问题规模之间的关系。
- 算法的时间复杂度分为：
   - 最好情况的时间复杂度
   - 最坏情况的时间复杂度
   - 平均情况的时间复杂度
   - 时间复杂度一般按最坏情况、平均情况两者之间处理，在处理应急事件时，计算机系统必须在规定的响应时间内做完紧急事件处理，最坏估计是唯一选择。
- 常见的时间复杂度及其关系：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

#### 渐进表示法
- 渐进表示法：不考虑具体的运行时间函数，只考虑运行函数的数量级。
- 定义：（大O）如果存在正的常数c和N1，当满足N>=N1时，有T(N)<=cF(N)，则T(N)是O(F(N))。
   - 大O表示法就是取运行时间函数的主项。
   - 在选择F(N)时，通常选择的是比较简单的函数形式，并忽略低次项和系数。
   ```
   🌰：
   设 T(n) = (n+1)2 
     那么，取n0 = 1 及 c=4 时，
     T(n) <= cn² 成立。
     所以，T(n) = O(n²) 
   ```
 
#### 时间复杂度的计算（大O表示法的计算）
- **大O表示法的计算**：时间复杂度的计算先定义标准操作，再计算标准操作的次数，得到一个标准操作次数和问题规模的函数。然后取出函数的主项，就是它的时间复杂度的大O表示。
   - **求和定理**：假定T1(n)、T2(n)是程序P1、P2的运行时间，并且T1(n)是O(f(n))的，而T2(n)是O(g(n))的。那么，先运行P1、再运行P2 的总的运行时间是：**T1(n)＋T2(n)＝O(MAX(f(n)，g(n))**。
   - **求积定理**：如果T1(n) 和 T2(n)分别是O(f(n))和O(g(n))的，那么**T1(n)×T2(n)=O(f(n)×g(n))** 。
- 大O表示法的计算规则：
   1. **简单语句**，例如赋值语句、输入输出语句，它们的运行时间与问题规模无关，在每个计算机系统中运行时间都是一个常量，因此时间复杂度为**O(1)**。
   2. **条件语句**，if <条件> then <语句> else <语句>，的运行时间为执行条件判断的代价 ，一般为O(1)，再加上执行 then 后面的语句的代价(若条件为真)，或执行else 后面的语句代价(若条件为假)之和，即max(O(then子句)，O(else子句))。
   3. **循环语句**，执行时间是循环控制行和循环体执行时间的总和。循环控制一般是一个简单的条件判断，因此循环语句的执行时间是循环体的运行时间乘循环次数。
   ```
   🌰1：
   for(j=1;j<=10000;++j)
   {++x; s+=x;}
   //该段程序的时间复杂度为O(1)
   🌰2：
  for(j=1;j<=n;++j)
   {++x; s+=x;}
   //该段程序的时间复杂度为O(n)
   🌰3：
   for(k=1; k<=n; k*=2)
     for(j=1; j<=n; j+=1)
          count++; 
   //该段程序的时间复杂度为O(nlog(2)n)，（2）表示底数为2
   ```
   4. **嵌套循环语句**，对外层循环的每个循环周期，内存循环都要执行它的所有循环周期，因此，可用求积定理计算整个循环的时间复杂度，即最内层循环体的运行时间乘所有循环的循环次数。
   ```
   🌰1：
   for (i=0; i<n; i++)
       for (j=0; j<n; j++) k++;
   //的时间复杂性为O(n²)
   🌰2：
    for (i=0; i<n; i++) a[i]=0;
    for (i=0; i<n; i++)
        for (j=0; j<n; j++) a[i]= i+j;
    //第一个循环体的复杂度为O(n)，第二个循环的时间赋值度为O(n²)，根据求和定理，整段程序的时间复杂度为O(n²)
   ```
   
### 算法的空间复杂度
- 固定空间需求：与处理的问题规模无关。
- 可变空间需求：与处理的数据量有关。
- 空间复杂度一般按最坏情况处理。

  













