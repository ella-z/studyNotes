# 线性表
- [线性表是什么](#线性表是什么)
- [线性表的顺序实现](#线性表的顺序实现)
   - [顺序表](#顺序表)
- [线性表的链接实现](#线性表的链接实现)
   - [单链表](#单链表)
   - [双链表](#双链表)
   - [循环链表](#循环链表)

## 线性表是什么
- 线性表是N个具有相同特征的节点构成的集合，在这个集合中，除了第一个节点A(0)与最后一个节点A(N-1)外，每个元素都有唯一的前驱和后续。对于每个A(i)
，它的前驱是A(i-1)，它的后继是A(i+1)。A(0)只有后继没有前驱，A(N-1)只有前驱没有后继。

## 线性表的顺序实现
### 顺序表
- 按索引值从小到大存放在一片相邻的连续区域。
- 紧凑结构，存储密度为1。
<br />
<img src="" title="顺序表" width="500px" height="50px">

#### 线性表的顺序存储
- 一块连续的存储空间可以用一个数组实现，由于线性表中的元素个数是动态的，因此采用了动态数组。
- 保存一个动态数组，需要三个变量：指向线性表元素类型的指针，数组规模（容量），数组中的元素个数（表长）。
- 顺序表的运算实现：
   - 查找实现
   ```
     🌰(JAVA)：
     //客户端
     public class client {
      public static void main(String[] args) {
        // TODO Auto-generated method stub
            int[] arr= {1,2,3,4,5,6,7,8,9,};
            search find = new search();
            int result = find.search(arr, 5); //传递数组以及想要查询的值
            System.out.println(result);
      }
    }
    //search类中
      public int search(int[] data,int target) {
      int len = data.length;
      int num = 0;
      for (num=0;num<len;num++) {
        if(data[num] == target) break;
        if(num == len) num = -1;
      }
      return num;
    }
   ```
   ```
   🌰(JS)：
     function search(array,target){
        for(let i=0;i<array.length;i++){
            if(array[i] === target){
                return i;
            }else if(i === array.length){
                return -1;
            }
        }
    }
    let array = [1,2,3,4,5,6,7,8,9]
    let result = this.search(array,5);
   ```
   - 插入实现
      - 在JAVA中，在插入时，表长会增长。当表长等于容量时，新增的元素无法存储，所以先要扩大数组容量再插入新的元素。
   ```
    🌰(JAVA)：
    public class Insert {
      public Insert(int[] arr,int newData,int index) {
      // arr是目标数组，newData是要插入的数据，index是要插入的位置
        int[] arr1 = new int[arr.length+1];
        for(int i =0 ;i<arr.length;i++) {
          arr1[i] = arr[i];
        }
        for(int j=arr1.length-1;index<=j;j--) {
          arr1[j] = arr1[j-1];
        }
        arr1[index] = newData;
      }
    }
   ```
   ```
     🌰(JS)：
     //在数组末尾添加，push()
     function insert(array,newData){
        array.push(newData);
     }
     let array = [1,2,3,4,5,6,7,8,9]
     this.insert(array,10);

     //在数组开头添加,unshift
     function insert(array,newData){
          array.unshift(newData);
      }
      let array = [1,2,3,4,5,6,7,8,9]
      this.insert(array,10);  

      //在特定位置添加可以使用splice(index,num,newData)实现,position为位置，num删除的数量，若num为0就是不删除，newData新的元素
       function insert(array,index,num,newData){
          array.splice(position,num,newData);
      }

      let array = [1,2,3,4,5,6,7,8,9]
      this.insert(array,5,0,10);  
   ```
   - 删除实现
   ```
     🌰(JAVA)：
      public class remove {
      public remove(int[] array,int index) {  
        int[] array1 = new int[array.length-1];
        for(int i = index;i<array.length-1;i++) {
          array[i] = array[i+1];
        }
        for(int i = 0;i<array1.length;i++) {
          array1[i] = array[i];
        }
      }
    }
   ```
   ```
     🌰(JS)：
      //slice(start,end)，方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素，不会改变原数组。
      //start参数：该参数是数组片断开始处的数组下标。如果不指定，那么从0开始。如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。
      //end参数：该参数是数组片断结束处的数组下标。如果不指定，那么切分的数组包含从start到数组结束的所有元素。如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。
      function remove(array,start,end){
          return array.slice(start,end);
      }

      let array = [1,2,3,4,5,6,7,8,9]
      let result = this.remove(array,5,8);  
      
      //使用splice，略
      
      //pop方法，该方法会弹出数组中最后一个元素，并返回，会改变原数组
      function remove(array){
          return array.pop();
      }

      let array = [1,2,3,4,5,6,7,8,9]
      let result = this.remove(array);  
      console.log(result);//9
      console.log(array);[1,2,3,4,5,6,7,8]
      
      //filter方法，将删除元素过滤掉
      function remove(array,target){
        return array = array.filter(item =>{
            return item !=target
        });
    }

    let array = [1,2,3,4,5,6,7,8,9]
    let result = this.remove(array,5);  

    console.log(result); // [1, 2, 3, 4, 6, 7, 8, 9]
   ```
### 线性表的顺序存储的缺点
- 由于要保持逻辑次序和物理次序的一致性，顺序表在插入删除时需要移动大量的数据，性能不太理想。
### 线性表的顺序存储的优点
- 由于逻辑次序和物理次序的一致性使得定位访问的性能很好。
### 什么时候使用顺序表
- 顺序表比较适合静态的、经常做定位访问的线性表。


## 线性表的链接实现
- 用指针实现变长的线性存储结构。
- 将每个结点放在一个独立的存储单位，结点间的逻辑关系依靠存储单元中附加的指针来给出。
- 结点的存储单元在物理位置上可以相邻，也可以不相邻。

## 单链表
<br />
<img src="" title="单链表" width="500px" height="70px">

- 存储的结点组成:数据字段+指针字段(后继地址)。
- 关于元首结点、头结点、头指针的区别：
   <br />
   <img src="" title="元首结点、头结点、头指针" width="500px" height="70px">
   
   - 首元结点：是指链表中存储线性表第一个数据元素的结点,也称为第一元素结点。
   - 头结点：是在链表的首元结点之前附设的一个结点。数据域内只放空表标志,表长等信息或者是空的，也可做监视哨。
      - 头结点的意义：头节点不是线性表中的组成部分，头结点的出现，是为了在表头位置上进行插入和删除和在其它结点位置上是完全一致的，从而使得插入和删除算法得到简化。 
   - 头指针：是指向链表中第一个结点（有头结点的指向头结点，无头结点则指向首元结点）的指针。 单链表可由一个头指针唯一确定，能够标识一个单链表，也常做链表的名字。

## 双链表
## 循环链表
