# 模块打包
## CommonJs
### CommonJs是什么
   - CommonJs是包含模块、文件、IO、控制台的一系列标准。
### CommonJs与原生的写法有何不同
   - CommonJs中规定每一个文件是一个模块，与原生最大的区别在于原生的js文件会通过script标签直接插入页面中，那么原生写法的作用域为全局作用域，在进行变量以及
函数声明的时候会污染全局变量。而CommonJs会将js文件封装成模块使用require进行引入，会形成一个属于该js文件模块自身的作用域，所有变量以及函数只能自己访问。
### CommonJs中如何将模块中的方法暴露出去给别的模块使用
   - CommonJs中可以通过module.export的方式进行导出，或者简写成export.xxx的形式。
   - **注意**：我们若在同一个文件里面同时使用export.xxx或者module.export的时候，不能将module.export写在export.xxx之后export.xxx会被覆盖。
### CommonJs中如何导入别的模块中暴露出来的方法
   - CommonJs中使用require进行模块的引入，再通过引入的对象进行方法的调用。
      - 在调用的时候会有两种情况：
         - require的模块是第一次被加载，那么就会先执行这个模块再导出内容。
         - require的模块曾被加载过，这时该模块的代码就不会再次执行，而是直接导出上次执行后的结果。（模块中的module对象中会有个对象loaded记录改模块是否被加载过。
         

## ES6
### ES6是什么什么
- ES6是标准委员会制定的模块、文件等一系列标准。ES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，并且ES6 Module会自动采用严格模式。
### ES6导出
- ES6中使用export命令来导出模块。
### ES6导入
- ES6中导入是使用 import命令。
   - 🌰：import { something } from “a.js”
- 在导入多个变量的时候 我们可以采用整体导入的方式。
   - 🌰：import * as myModule from “a.js”
- 只导出默认导出
   - 🌰：import default from “a.js”

## ES6与CommonJs的区别
### 动态与静态
- CommonJs是动态的，模块依赖的关系建立发生在代码运行阶段，require的模块路径可以动态指定，所以在模块执行前，并没有办法确定明确的依赖关系，模块的导入、导出发生在代码的运行阶段。
- ES6 Module是静态的，模块依赖的关系建立在代码编译的阶段。导入导出语句都是声明式的，它不支持导入的路径是动态的，并且导入导出语句必须位于模块的顶层作用域。
- ES6相比于CommonJs具有几点优势：
   - 死代码检测和排除。我们可以静态分析哪些模块没有被调用过，在打包时可以去掉这些未曾使用过的模块，减小打包资源体积。
   - 模块变量类型检查。js属于动态类型语言，不会在代码前检查类型错误。ES6的静态模块结构有助于确保模块之间传递的值或接口类型是正确的。
   - 编译器优化。在CommonJs等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而ES6支持直接导入变量，减少了引用层级，程序效率更高。
### 值拷贝与动态映射
- 在导入一个模块的时候，CommonJs来说获取的是一份导出值的拷贝，而在ES6中则是值的动态映射，并且这个映射是只读的。
- CommonJs中允许对导入的值进行更改，并且由于CommonJs是值拷贝，这些操作不会对原本的模块有影响。
- ES6中导入的变量其实是对原有值的动态映射。当我们通过模块中的方法修改模块中的值的时候，原本已经导入的值也会被修改，我们不能在index.js中对模块中导入的值进行修改，因为这种映射是只能只读的。

## AMD
### AMD是什么
- 异步模块定义的缩写。与CommonJs以及ES6的最大区别就是与它是异步的。
- 🌰：
   


